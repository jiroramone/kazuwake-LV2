<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ã‹ãšã‚ã‘ã‚²ãƒ¼ãƒ ï¼ˆã‚„ã•ã—ã„ç‰ˆï¼‰</title>
    <!-- Tailwind CSS CDN (ã‚«ã‚¹ã‚¿ãƒ CSSã§ä¸Šæ›¸ãã•ã‚Œã‚‹éƒ¨åˆ†ãŒå¤šã„ã§ã™ãŒã€å¿µã®ãŸã‚æ®‹ã—ã¾ã™) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›ã®CSSã‚’ã“ã“ã«é…ç½® */
        body {
            font-family: "Arial", sans-serif;
            text-align: center;
            background-color: #f0f8ff;
            padding: 20px;
            overflow: hidden; /* èŠ±ç«ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã« */
        }
        h1 {
            font-size: 28px;
            color: #444;
        }
        #question {
            font-size: 24px;
            margin-bottom: 10px;
        }
        #drop-container {
            text-align: center;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        .drop-zone {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 80px;
            height: 80px;
            border: 2px dashed #aaa;
            background-color: #fff;
            overflow: visible;
            line-height: normal;
        }
        #plus {
            font-size: 32px;
            user-select: none;
        }
        #cards {
            margin-top: 0; /* ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›CSSã«åˆã‚ã›ã‚‹ */
            display: flex;
            justify-content: center;
            gap: 10px;
            user-select: none;
            flex-wrap: wrap;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        .card {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 75px; /* å¤‰æ›´ç®‡æ‰€: å¤§ãã•ã‚’å¤§ãã */
            height: 75px; /* å¤‰æ›´ç®‡æ‰€: å¤§ãã•ã‚’å¤§ãã */
            background-color: #ffa;
            border: 1px solid #aaa;
            border-radius: 12px;
            padding: 5px;
            margin: 5px;
            user-select: none;
            text-align: center;
            touch-action: none;
            cursor: grab;
        }
        .card strong {
            font-size: 20px;
            line-height: 1;
            margin-bottom: 4px; /* å¤‰æ›´ç®‡æ‰€: é–“éš”ã‚’å°‘ã—ç‹­ã‚ã‚‹ */
        }
        .dots {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            background-color: #007bff;
            border-radius: 8px;
            padding: 4px 8px;
            user-select: none;
            min-width: 40px;
            height: 40px;
            box-sizing: border-box;
        }
        .dots-row {
            display: flex;
            justify-content: center;
            gap: 6px;
            line-height: 1;
            margin: 1px 0;
        }
        #result {
            margin-top: 0.25rem; /* é–“éš”ã‚’ã•ã‚‰ã«ç‹­ã‚ã‚‹ */
            font-size: 22px;
            color: green;
            white-space: pre-wrap;
            min-height: 80px;
            font-weight: bold;
            text-align: center;
            user-select: none;
            position: relative; /* ç”»åƒã‚’é‡ã­ã‚‹ãŸã‚ã«å¿…è¦ */
            display: flex; /* å­è¦ç´ ã‚’ä¸­å¤®ã«é…ç½®ã™ã‚‹ãŸã‚ã«flexã‚’ä½¿ç”¨ */
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #result div { /* å›ç­”ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
            position: relative; /* ç”»åƒã®ä¸Šã«è¡¨ç¤º */
            z-index: 10; /* ç”»åƒã‚ˆã‚Šæ‰‹å‰ã«è¡¨ç¤º */
            background-color: rgba(255, 255, 255, 0.7); /* ãƒ†ã‚­ã‚¹ãƒˆã®èƒŒæ™¯ã‚’åŠé€æ˜ã«ã—ã¦ç”»åƒã‚’é€ã‹ã™ */
            padding: 0.25rem 0.5rem; /* ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚° */
            border-radius: 0.5rem;
        }
        .big-circle {
            width: 100px; /* å¤§ãã•ã‚’å¤§ãã */
            height: 100px; /* å¤§ãã•ã‚’å¤§ãã */
            margin-bottom: 0; /* ç”»åƒã¨ãƒ†ã‚­ã‚¹ãƒˆã®é–“éš”ã‚’ãªãã™ */
            user-select: none;
            position: absolute; /* è¦ªè¦ç´ ã®ä¸­å¤®ã«é…ç½® */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15; /* ãƒ†ã‚­ã‚¹ãƒˆã‚ˆã‚Šæ‰‹å‰ã«è¡¨ç¤º */
            opacity: 1; /* èŠ±ä¸¸ã‚’ä¸é€æ˜ã«ã™ã‚‹ */
        }

        /* æ—¢å­˜ã®Tailwindã‚¯ãƒ©ã‚¹ã¨ç«¶åˆã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èª¿æ•´ */
        .game-area {
            /* ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›CSSã«ã¯game-areaã®å®šç¾©ãŒãªã„ãŸã‚ã€æ—¢å­˜ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èª¿æ•´ */
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff;
            padding: 1.5rem; /* ã‚¹ãƒãƒ›ã§ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å°‘ã—æ¸›ã‚‰ã™ */
            border-radius: 1.5rem; /* rounded-3xl */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1); /* shadow-xl */
            width: 100%;
            max-width: 800px; /* æœ€å¤§å¹…ã¯ç¶­æŒ */
            box-sizing: border-box;
        }
        #cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem; /* gap-3 ã‚«ãƒ¼ãƒ‰é–“ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’å°‘ã—åºƒã’ã‚‹ */
            margin-top: 0.5rem; /* #result ã¨ #cards ã®é–“éš”ã‚’ç‹­ã‚ã‚‹ */
            min-height: 6rem; /* Ensure space for cards */
        }
        #drop-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px; /* ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›CSSã«åˆã‚ã›ã‚‹ */
            flex-wrap: wrap; /* å°ã•ã„ç”»é¢ã§æŠ˜ã‚Šè¿”ã™å¯èƒ½æ€§ã‚’è€ƒæ…® */
        }
        .restart-button {
            background-color: #10b981; /* Green button */
            color: white;
            padding: 0.75rem 1.5rem; /* py-3 px-6 */
            border-radius: 0.75rem; /* rounded-xl */
            font-size: 1.125rem; /* text-lg */
            font-weight: bold;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            margin-top: 2rem; /* mt-8 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .restart-button:hover {
            background-color: #059669; /* Darker green on hover */
            transform: translateY(-2px);
        }
        .restart-button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        /* Small screen specific adjustments */
        @media (max-width: 640px) {
            h1 {
                font-size: 1.75rem;
            }
            #question {
                font-size: 1.5rem;
            }
            #plus {
                font-size: 1.5rem;
                margin: 0 0.5rem;
            }
            .card {
                width: 65px; /* ã‚¹ãƒãƒ›ã§èª¿æ•´ */
                height: 65px; /* ã‚¹ãƒãƒ›ã§èª¿æ•´ */
                margin: 3px;
            }
            .drop-zone {
                width: 70px; /* ã‚¹ãƒãƒ›ã§èª¿æ•´ */
                height: 70px; /* ã‚¹ãƒãƒ›ã§èª¿æ•´ */
                margin: 3px;
            }
            .card strong {
                font-size: 1.25rem;
            }
            .dots-row {
                font-size: 0.65rem;
            }
            #cards {
                gap: 5px; /* ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›CSSã®10pxã‹ã‚‰ã•ã‚‰ã«ç‹­ã‚ã‚‹ */
            }
            .restart-button {
                font-size: 1rem;
                padding: 0.6rem 1.2rem;
            }
        }

        /* èŠ±ç«ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #fireworksCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999; /* æœ€å‰é¢ã«è¡¨ç¤º */
            pointer-events: none; /* ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€éã•ã›ã‚‹ */
            background-color: black; /* å¤‰æ›´ç®‡æ‰€: èƒŒæ™¯ã‚’å®Œå…¨ã«ä¸é€æ˜ãªé»’ã« */
        }
    </style>
</head>
<body>
    <div class="game-area">
        <h1>ã‹ãšã‚ã‘ã‚²ãƒ¼ãƒ ï¼ˆã‚„ã•ã—ã„ç‰ˆï¼‰</h1>

        <div id="question">å•é¡Œ</div>

        <div id="drop-container">
            <div class="drop-zone" id="slot1"></div>
            <span id="plus">ã¨</span>
            <div class="drop-zone" id="slot2"></div>
        </div>

        <!-- #result ã®ä½ç½®ã‚’ #drop-container ã¨ #cards ã®é–“ã«ç§»å‹• -->
        <div id="result"></div>

        <div id="cards"></div>
        
        <button id="restartButton">ã‚‚ã†ã„ã¡ã© ã¯ã˜ã‚ã‹ã‚‰</button>
    </div>

<script>
    const allTargets = [3, 4, 5, 6, 7, 8, 9, 10];
    let targets = [];
    let currentIndex = 0;
    let currentTarget = null;
    const usedPairs = new Set();
    let draggedCard = null; // To store the card being dragged (for desktop)
    let touchedCard = null; // To store the card being touched (for mobile)

    // Utility function to shuffle an array
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Creates a number card with value and dots representation.
     * @param {number} n - The number value for the card.
     * @param {boolean} isDraggable - True if the card should be draggable/touchable (for cards in the 'cards' area).
     * @returns {HTMLDivElement} The created card element.
     */
    function createCard(n, isDraggable = false) {
        const div = document.createElement('div');
        div.className = 'card'; // æä¾›ã•ã‚ŒãŸCSSã®.cardã‚¹ã‚¿ã‚¤ãƒ«ãŒé©ç”¨ã•ã‚Œã‚‹
        div.dataset.value = n; // Store the number value

        let dotsHtmlContent = ''; // ãƒ‰ãƒƒãƒˆã®HTMLå†…å®¹
        if (n <= 5) {
            // For numbers 1-5, display dots in a single row
            dotsHtmlContent = `<span class="dots-row">${'â—'.repeat(n)}</span>`;
        } else {
            // For numbers 6-10, display dots in two rows for better visual clarity
            let topCount, bottomCount;
            switch (n) {
                case 6: topCount = 3; bottomCount = 3; break;
                case 7: topCount = 4; bottomCount = 3; break;
                case 8: topCount = 4; bottomCount = 4; break;
                case 9: topCount = 5; bottomCount = 4; break;
                case 10: topCount = 5; bottomCount = 5; break;
                default:
                    // Fallback for unexpected numbers (should not happen with current targets)
                    topCount = Math.ceil(n / 2);
                    bottomCount = n - topCount;
            }
            dotsHtmlContent =
                `<span class="dots-row">${'â—'.repeat(topCount)}</span>` +
                `<span class="dots-row">${'â—'.repeat(bottomCount)}</span>`;
        }

        // Set the inner HTML of the card. .dotsã‚¯ãƒ©ã‚¹ã‚’æŒã¤divã§ãƒ‰ãƒƒãƒˆã‚’å›²ã‚€ã€‚
        div.innerHTML = `<strong>${n}</strong><div class="dots">${dotsHtmlContent}</div>`;

        if (isDraggable) {
            div.classList.add('draggable-card'); // Add a class for draggable styling (ãƒ¦ãƒ¼ã‚¶ãƒ¼CSSã§å®šç¾©)
            div.setAttribute('draggable', true); // Make the card draggable

            // Add event listeners for drag and touch interactions
            div.addEventListener('dragstart', (e) => {
                draggedCard = e.currentTarget; // Store reference to the dragged card
                e.dataTransfer.setData("text/plain", n); // Set data for drag operation
                e.dataTransfer.effectAllowed = "move"; // Indicate a move operation
            });

            div.addEventListener('touchstart', touchStart, { passive: false }); // Use passive: false for preventDefault
            div.addEventListener('touchmove', touchMove, { passive: false });
            div.addEventListener('touchend', touchEnd);
        }

        return div;
    }

    // Populates the card area with numbers from 0 up to the current target
    function setupCards(target) {
        const cardArea = document.getElementById('cards');
        cardArea.innerHTML = ''; // Clear existing cards
        // Create cards for numbers from 0 to the target number, making them draggable
        for (let i = 0; i <= target; i++) {
            const card = createCard(i, true); // Pass true to make these cards draggable
            cardArea.appendChild(card);
        }
    }

    // Allows dropping elements into the drop zone
    function allowDrop(ev) {
        ev.preventDefault(); // Prevent default to allow drop
        // Add a visual indicator when an element is dragged over
        if (ev.target.classList.contains("drop-zone")) {
            ev.target.classList.add("drag-over");
        }
    }

    // Removes the visual indicator when a dragged element leaves the drop zone
    function dragLeave(ev) {
        if (ev.target.classList.contains("drop-zone")) {
            ev.target.classList.remove("drag-over");
        }
    }

    // Handles the drop event for desktop drag-and-drop
    function drop(ev) {
        ev.preventDefault(); // Prevent default drop behavior
        const value = parseInt(ev.dataTransfer.getData("text/plain")); // Get the value of the dropped card
        const dropZone = ev.target.closest('.drop-zone'); // Find the closest drop zone element

        if (!dropZone) return; // If not dropped on a drop zone, do nothing

        dropZone.classList.remove("drag-over"); // Remove drag-over styling

        // If there's already a card in the drop zone, clear it (the old card is implicitly "returned" to the pool)
        if (dropZone.firstElementChild) {
            dropZone.innerHTML = '';
        }
        
        // Create a new card element for the dropped value and append it to the drop zone
        const newCard = createCard(value);
        dropZone.appendChild(newCard);

        checkAnswer(); // Check the answer after dropping
        draggedCard = null; // Clear the dragged card reference
    }

    // Resets the content of both drop slots and the result area
    function resetSlots() {
        document.getElementById("slot1").innerHTML = '';
        document.getElementById("slot2").innerHTML = '';
        updateResult(''); // çµæœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ç”»åƒã‚’ã‚¯ãƒªã‚¢
    }

    // Updates the question displayed to the user
    function updateQuestion() {
        // Check if all questions have been cleared
        if (currentIndex >= targets.length) {
            updateResult("ğŸ‰ ã™ã¹ã¦ã®ã‚‚ã‚“ã ã„ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼ãŠã‚ã§ã¨ã†ï¼", 'success');
            document.getElementById('question').textContent = "ãŠã—ã¾ã„";
            resetSlots();
            document.getElementById('cards').innerHTML = ''; // Clear all cards
            showFireworks(); // å…¨å•ã‚¯ãƒªã‚¢æ™‚ã«èŠ±ç«ã‚’è¡¨ç¤º
            return;
        }

        currentTarget = targets[currentIndex]; // Get the current target number
        document.getElementById('question').textContent = `${currentTarget} ã¯ ã„ãã¤ ã¨ ã„ãã¤ï¼Ÿ`;
        resetSlots(); // Clear the drop slots (ã“ã‚Œã«ã‚ˆã‚Šçµæœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚ã‚¯ãƒªã‚¢ã•ã‚Œã‚‹)
        setupCards(currentTarget); // Re-populate cards for the new target
        usedPairs.clear(); // Clear used pairs for the new question
        // updateResult(''); // resetSlots()ã§å‘¼ã°ã‚Œã‚‹ãŸã‚ä¸è¦
    }

    // Updates the result message displayed to the user
    function updateResult(text, type = '') {
        const result = document.getElementById('result');
        result.innerHTML = ''; // Clear previous content
        result.className = ''; // ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
        result.classList.add('result-text'); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›CSSã®#resultã‚¹ã‚¿ã‚¤ãƒ«ãŒé©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«èª¿æ•´

        if (type === 'success') {
            // Display a success message with a hanamaru image
            result.classList.add('correct-feedback');
            // Using the uploaded hanamaru.png image URL.
            result.innerHTML = `
                <img src="hanamaru.png" alt="èŠ±ä¸¸" class="big-circle">
                <div>${text.replace(/\n/g, '<br>')}</div>
            `;
        } else if (type === 'incorrect') {
            result.classList.add('incorrect-feedback');
            result.textContent = text;
        } else if (type === 'info') {
            result.classList.add('info-feedback');
            result.textContent = text;
        } else {
            result.textContent = text; // Default text
        }
    }

    // Checks if the numbers in the slots add up to the current target
    function checkAnswer() {
        const slot1 = document.getElementById("slot1").firstElementChild;
        const slot2 = document.getElementById("slot2").firstElementChild;

        // Ensure both slots have cards
        if (!slot1 || !slot2) return;

        // Parse the values from the cards
        const a = parseInt(slot1.dataset.value);
        const b = parseInt(slot2.dataset.value);

        // Check if the sum is correct
        if (a + b === currentTarget) {
            // Create a unique key for the pair to track used combinations (e.g., "2,3" is same as "3,2")
            const key = [a, b].sort((x, y) => x - y).join(',');
            if (!usedPairs.has(key)) {
                usedPairs.add(key); // Add the new valid pair
                // Calculate remaining combinations
                // For target N, pairs are (0,N), (1,N-1), ..., (floor(N/2), ceil(N/2))
                // Number of unique pairs is floor(N/2) + 1
                const totalPairs = Math.floor(currentTarget / 2) + 1;
                const left = totalPairs - usedPairs.size;

                let message = `ã›ã„ã‹ã„ï¼ ${a} ã¨ ${b} ã§ ${currentTarget} ã«ãªã‚‹ã‚ˆï¼\n`;
                message += `ã®ã“ã‚Šã®ãã¿ã‚ã‚ã›ï¼š${left}ã“`;
                updateResult(message, 'success');

                if (left === 0) {
                    // All combinations found, move to the next question
                    message += "\nãœã‚“ã¶ã® ãã¿ã‚ã‚ã›ãŒ ã¿ã¤ã‹ã£ãŸã‚ˆï¼ã¤ãã®ã‚‚ã‚“ã ã„ã¸ï¼";
                    updateResult(message, 'success');
                    currentIndex++;
                    setTimeout(() => {
                        updateQuestion(); // Load next question after a short delay
                    }, 1500); // Increased delay for better user experience
                }
                setTimeout(() => {
                    resetSlots(); // Clear slots after a short delay
                }, 1500); // å¤‰æ›´ç®‡æ‰€: 1.5ç§’ã«è¨­å®š
            } else {
                updateResult("ãã® ãã¿ã‚ã‚ã›ã¯ ã‚‚ã† ã“ãŸãˆãŸã‚ˆã€‚", 'info');
                setTimeout(() => {
                    resetSlots();
                }, 1500); // å¤‰æ›´ç®‡æ‰€: 1.5ç§’ã«è¨­å®š
            }
        } else {
            updateResult("ã¡ãŒã†ã‚ˆã€‚ã‚‚ã† ã„ã¡ã©ï¼", 'incorrect');
            setTimeout(() => {
                resetSlots();
            }, 1500); // å¤‰æ›´ç®‡æ‰€: 1.5ç§’ã«è¨­å®š
        }
    }

    // --- Touch Event Handlers ---

    // Stores the touched card on touch start
    function touchStart(e) {
        e.preventDefault(); // Prevent default scrolling/zooming
        touchedCard = e.currentTarget;
        // Optionally, add a visual feedback like a class for active state
        touchedCard.classList.add('scale-105', 'shadow-lg');
    }

    // Prevents default touchmove behavior (like scrolling)
    function touchMove(e) {
        e.preventDefault();
        // Optional: Implement visual feedback for dragging (e.g., move a ghost element)
        // This is more complex and might not be necessary for a "simple" version.
    }

    // Handles the touch end event to drop the card
    function touchEnd(e) {
        const touch = e.changedTouches[0];
        // Find the element under the touch point
        const elem = document.elementFromPoint(touch.clientX, touch.clientY);
        const dropZone = elem ? elem.closest('.drop-zone') : null; // Find the closest drop zone element

        if (touchedCard) {
            touchedCard.classList.remove('scale-105', 'shadow-lg'); // Remove active state
        }

        if (dropZone) {
            const value = parseInt(touchedCard.dataset.value); // Get the value of the touched card

            // If there's already a card in the drop zone, clear it
            if (dropZone.firstElementChild) {
                dropZone.innerHTML = '';
            }

            // Create a new card element for the touched value and append it to the drop zone
            const newCard = createCard(value);
            dropZone.appendChild(newCard);

            checkAnswer(); // Check the answer
        } else if (touchedCard && touchedCard.parentElement.classList.contains('drop-zone')) {
            // If the card was in a drop zone but dropped outside, remove it from the slot
            touchedCard.parentElement.innerHTML = '';
        }
        touchedCard = null; // Clear the touched card reference
    }

    // --- Fireworks Animation ---
    let fireworksCanvas = null;
    let fireworksCtx = null;
    let fireworks = [];
    let animationFrameId = null;

    // èŠ±ç«ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¡¨ç¾ã™ã‚‹ã‚¯ãƒ©ã‚¹
    class FireworkParticle {
        constructor(x, y, radius, color, alpha, speed) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.alpha = alpha;
            this.speed = speed;
        }

        update() {
            this.radius += this.speed;
            this.alpha -= 0.01; // å¾ã€…ã«é€æ˜ã«ãªã‚‹
        }

        draw() {
            if (fireworksCtx) {
                fireworksCtx.beginPath();
                fireworksCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                fireworksCtx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha})`;
                fireworksCtx.fill();
            }
        }
    }

    // èŠ±ç«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function showFireworks() {
        // æ—¢å­˜ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒã‚ã‚Œã°å‰Šé™¤
        if (fireworksCanvas) {
            fireworksCanvas.remove();
            cancelAnimationFrame(animationFrameId);
            fireworks = [];
        }

        fireworksCanvas = document.createElement('canvas');
        fireworksCanvas.id = 'fireworksCanvas';
        document.body.appendChild(fireworksCanvas);

        fireworksCtx = fireworksCanvas.getContext('2d');
        fireworksCanvas.width = window.innerWidth;
        fireworksCanvas.height = window.innerHeight;

        // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã§ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’æ›´æ–°
        window.addEventListener('resize', () => {
            if (fireworksCanvas) {
                fireworksCanvas.width = window.innerWidth;
                fireworksCanvas.height = window.innerHeight;
            }
        });

        // èŠ±ç«ã‚’ç”Ÿæˆã™ã‚‹é–“éš” (ãƒŸãƒªç§’)
        const spawnInterval = 300;
        let lastSpawnTime = 0;

        function animateFireworks(currentTime) {
            animationFrameId = requestAnimationFrame(animateFireworks);

            fireworksCtx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);

            // æ–°ã—ã„èŠ±ç«ã‚’ç”Ÿæˆ
            if (currentTime - lastSpawnTime > spawnInterval) {
                const x = Math.random() * fireworksCanvas.width;
                const y = Math.random() * fireworksCanvas.height * 0.8; // ç”»é¢ä¸Šéƒ¨2/3ã«é›†ä¸­
                const startRadius = 5;
                const speed = 1 + Math.random() * 2;
                const color = {
                    r: Math.floor(Math.random() * 255),
                    g: Math.floor(Math.random() * 255),
                    b: Math.floor(Math.random() * 255)
                };
                const initialAlpha = 1;

                // è¤‡æ•°ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã§ä¸€ã¤ã®èŠ±ç«ã‚’è¡¨ç¾
                for (let i = 0; i < 10; i++) { // 10å€‹ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã§ä¸€ã¤ã®èŠ±ç«
                    fireworks.push(new FireworkParticle(x, y, startRadius, color, initialAlpha, speed));
                }
                lastSpawnTime = currentTime;
            }

            // èŠ±ç«ã‚’æ›´æ–°ãƒ»æç”»
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const p = fireworks[i];
                p.update();
                p.draw();

                if (p.alpha <= 0) {
                    fireworks.splice(i, 1); // é€æ˜ã«ãªã£ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
                }
            }
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        animateFireworks(0);

        // 5ç§’å¾Œã«èŠ±ç«ã‚’åœæ­¢ã—ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å‰Šé™¤
        setTimeout(() => {
            cancelAnimationFrame(animationFrameId);
            if (fireworksCanvas) {
                fireworksCanvas.remove();
            }
            fireworks = []; // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…åˆ—ã‚’ã‚¯ãƒªã‚¢
        }, 5000); // 5ç§’é–“è¡¨ç¤º
    }

    // Initializes the game
    function startGame() {
        targets = allTargets.slice(); // Copy all targets
        shuffleArray(targets); // Randomize the order of questions
        currentIndex = 0; // Start from the first question
        updateQuestion(); // Display the first question
        document.getElementById('restartButton').addEventListener('click', startGame);

        // Add event listeners to drop zones
        document.getElementById('slot1').addEventListener('dragover', allowDrop);
        document.getElementById('slot1').addEventListener('dragleave', dragLeave);
        document.getElementById('slot1').addEventListener('drop', drop);

        document.getElementById('slot2').addEventListener('dragover', allowDrop);
        document.getElementById('slot2').addEventListener('dragleave', dragLeave);
        document.getElementById('slot2').addEventListener('drop', drop);
    }

    // Start the game when the page loads
    window.onload = startGame;

</script>
</body>
</html>
